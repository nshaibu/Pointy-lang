# Pointy Language Specification v1.2.0

**Version:** 1.2.0  
**Date:** December 2025  
**Status:** Draft  
**Author:** Nafiu (github.com/nshaibu)  

## Abstract

This document defines the Pointy Language Specification version 1.2.0, introducing **Meta Events** - a powerful mechanism for dynamic, data-driven workflow orchestration.

**NOTE:** This specification is an extension of versions v1.0.0, v1.1.0, and v1.1.1

## Table of Contents

1. [Introduction](#1-introduction)
2. [Meta Events Overview](#2-meta-events-overview)
3. [Syntax Definition](#3-syntax-definition)
4. [Execution Modes](#4-execution-modes)
5. [Execution Model](#5-execution-model)
6. [Integration with Existing Features](#6-integration-with-existing-features)
7. [Dynamic Instruction Payload](#7-dynamic-instruction-payload)
8. [Error Handling](#8-error-handling)
9. [Grammar Specification](#9-grammar-specification)
10. [Examples](#10-examples)

---

## 1. Introduction

Meta Events represent a significant enhancement to Pointy Language's orchestration capabilities. They enable dynamic, data-driven execution patterns where the number and configuration of event executions are determined at runtime based on input data.

### 1.1 Design Goals

- **Dynamic Orchestration**: Support workflows where execution plans are generated at runtime
- **Collection Processing**: Provide first-class support for processing collections of data
- **Control Flow Patterns**: Implement common functional programming patterns (map, filter, reduce)
- **Composability**: Integrate seamlessly with existing Pointy Language features
- **Performance**: Enable efficient parallel processing of data collections

### 1.2 Use Cases

- Batch data processing across multiple items
- Dynamic fan-out to variable numbers of services
- Filtering and transformation pipelines
- Aggregation and reduction operations
- Conditional execution based on data characteristics
- Multi-tenant request processing

---

## 2. Meta Events Overview

### 2.1 Definition

A **Meta Event** is a reserved system component in Pointy Language that wraps and manages the execution of one or more **Template Events**. Its primary function is to interpret specialized flow instructions (execution modes) and generate dynamic execution plans for the Orchestrator.

### 2.2 Core Concepts

#### 2.2.1 Meta Event
A reserved system event (implemented as `ControlFlowEvent` in Python) that dictates complex control flow patterns such as fan-out, filtering, mapping, or reduction.

#### 2.2.2 Template Event
The Event identifier provided as the primary argument to a Meta Event, representing the unit of work that will be instantiated and executed according to the Meta Event's logic.

**CRITICAL CONSTRAINT**: Template Events MUST be regular Events (classes inheriting from `EventBase` or functions decorated with `@event`). Template Events CANNOT be Meta Events (`ControlFlowEvent`). Nested Meta Events are explicitly prohibited.

#### 2.2.3 Execution Mode
A required configuration parameter for a Meta Event that specifies the exact control flow pattern to be applied (e.g., `MAP`, `FILTER`, `REDUCE`).

#### 2.2.4 Dynamic Instruction Payload
A runtime-generated list of specific, fully configured task definitions (including unique IDs, input data, and the template class) that the Orchestrator must execute.

### 2.3 How Meta Events Work

1. **Definition**: A Meta Event is declared in Pointy script using the `<>` notation
2. **Runtime Encounter**: The Orchestrator encounters the Meta Event during pipeline execution
3. **Input Analysis**: The Meta Event's `process()` method analyzes the input data and execution mode
4. **Payload Generation**: A Dynamic Instruction Payload is created with specific task definitions
5. **Orchestration Handoff**: The Orchestrator intercepts the payload and executes the generated tasks
6. **Result Aggregation**: Results are collected and aggregated according to the mode's semantics
7. **Flow Resumption**: The main pipeline continues with the aggregated results

### 2.4 Restrictions and Constraints

#### 2.4.1 No Nested Meta Events

**PROHIBITION**: Template Events referenced by Meta Events MUST NOT be Meta Events themselves. Nesting Meta Events is explicitly forbidden.

**Rationale**:
- **Complexity**: Nested Meta Events create unpredictable execution patterns
- **Performance**: Nested dynamic task generation can cause exponential resource consumption
- **Debugging**: Multi-level nesting makes error tracing extremely difficult
- **Mental Model**: Keeps Meta Events as a single abstraction layer

**Enforcement**:
- **Parse Time**: Detect Meta Event syntax in Template Event position (where possible)
- **Initialization Time**: Validate that Template Event class is not `ControlFlowEvent`
- **Runtime**: Raise `NestedMetaEventError` if detected during execution

**Example of PROHIBITED Pattern**:
```pointy
# INVALID - Meta Event as Template Event
MAP<FILTER<ProcessItem>>  # ❌ NOT ALLOWED

# INVALID - Template Event internally uses Meta Event
MAP<ProcessGroup>  # ❌ NOT ALLOWED if ProcessGroup contains MAP/FILTER/etc.
```

**Correct Alternative Pattern**:
```pointy
# VALID - Flatten the logic explicitly
LoadGroups |-> 
FLATMAP<ExtractItems> |->      # Flatten groups to items
MAP<ProcessItem> |->            # Process all items
REDUCE<AggregateByGroup>       # Re-aggregate by group

# VALID - Sequential Meta Events
LoadData |-> MAP<Transform> -> FILTER<Validate> -> REDUCE<Aggregate>
```

**Error Message**:
When nested Meta Events are detected:
```
NestedMetaEventError: Meta Events cannot be used as Template Events. 
Found: MAP<FILTER<ProcessItem>>
Template Event 'FILTER<ProcessItem>' is a Meta Event, which is not allowed.
Use explicit sequential composition instead: MAP<Transform> -> FILTER<Validate>
```

---

## 3. Syntax Definition

### 3.1 Basic Meta Event Syntax

```
meta_event ::= mode '<' template_event '>' [attribute_list]
mode ::= 'MAP' | 'FILTER' | 'REDUCE' | 'FOREACH' | 'FLATMAP' | 'FANOUT'
template_event ::= identifier
```

**Example:**
```pointy
MAP<ProcessItem>
FILTER<ValidateRecord>
REDUCE<AggregateResults>
```

### 3.2 Meta Event with Attributes

Meta Events can have attributes that configure both the Meta Event behavior and the Template Event instances:

```pointy
MAP<ProcessItem>[batch_size=10, retries=3]
FILTER<ValidateRecord>[concurrent=true, timeout=30.0]
```

### 3.3 Meta Event in Pipelines

Meta Events can be used in all standard pipeline patterns:

#### Sequential Flow
```pointy
FetchDataList -> MAP<ProcessItem> -> SaveResults
```

#### Parallel Flow
```pointy
MAP<ProcessTypeA> || MAP<ProcessTypeB>
```

#### Result Piping
```pointy
FetchDataList |-> MAP<TransformItem> |-> REDUCE<Aggregate>
```

#### Conditional Branching
```pointy
MAP<ProcessItem> (
    0 -> LogErrors -> NotifyAdmin,
    1 -> SaveResults -> SendConfirmation
)
```

### 3.4 Grouped Meta Events

Meta Events can be grouped with execution chains:

```pointy
{FetchData -> MAP<ProcessItem> -> ValidateResults}[executor="ThreadPoolExecutor"]
```

---

## 4. Execution Modes

This section defines the standard execution modes supported by Meta Events.

### 4.1 MAP Mode

**Purpose:** Execute the Template Event for each item in the input collection.

**Syntax:**
```pointy
MAP<TemplateEvent>[attribute_list]
```

**Input Requirements:**
- Input must be a list/collection
- Each item becomes input to one Template Event instance

**Output:**
- List of results from each Template Event execution
- Order is preserved relative to input order
- Failed executions produce error entries

**Attributes:**
- `batch_size` (integer): Number of items to process per batch
- `concurrent` (boolean): Whether to execute instances in parallel
- `max_concurrency` (integer): Maximum number of parallel executions

**Example:**
```pointy
@items = [1, 2, 3, 4, 5]
LoadItems |-> MAP<ProcessItem>[batch_size=2, concurrent=true]
```

**Semantics:**
1. Input collection is partitioned according to `batch_size`
2. For each item, a Template Event instance is created with that item as input
3. All instances are executed (sequentially or concurrently based on `concurrent` attribute)
4. Results are collected in order and returned as a list

---

### 4.2 FILTER Mode

**Purpose:** Execute the Template Event as a predicate to filter items from the input collection.

**Syntax:**
```pointy
FILTER<TemplateEvent>[attribute_list]
```

**Input Requirements:**
- Input must be a list/collection
- Template Event must return a boolean-like descriptor (0 for exclude, 1 for include)

**Output:**
- List containing only items where Template Event returned success (descriptor 1)
- Original item data is preserved (not the Template Event's result)

**Attributes:**
- `concurrent` (boolean): Whether to execute filters in parallel
- `keep_on_error` (boolean): If true, keep items where Template Event failed; if false, exclude them

**Example:**
```pointy
@records = [{"age": 25}, {"age": 15}, {"age": 30}]
LoadRecords |-> FILTER<IsAdult>[concurrent=true] |-> ProcessAdults
```

**Semantics:**
1. For each item in input collection, Template Event is executed
2. Template Event should return descriptor 1 (include) or 0 (exclude)
3. Only items with descriptor 1 are included in output
4. Output preserves original item data, not Template Event results

---

### 4.3 REDUCE Mode

**Purpose:** Execute the Template Event progressively to aggregate/combine all items into a single result.

**Syntax:**
```pointy
REDUCE<TemplateEvent>[attribute_list]
```

**Input Requirements:**
- Input must be a list/collection with at least one item
- Template Event must accept two inputs: accumulator and current item

**Output:**
- Single aggregated result

**Attributes:**
- `initial_value` (any): Starting value for the accumulator (default: first item)
- `direction` (string): "left" for left-to-right, "right" for right-to-left (default: "left")

**Example:**
```pointy
@numbers = [1, 2, 3, 4, 5]
LoadNumbers |-> REDUCE<Sum>[initial_value=0] -> DisplayTotal
```

**Semantics:**
1. If `initial_value` is provided, use it as accumulator; otherwise use first item
2. For each subsequent item:
   - Execute Template Event with (accumulator, current_item)
   - Result becomes new accumulator
3. Final accumulator value is returned

---

### 4.4 FOREACH Mode

**Purpose:** Execute the Template Event for each item for side effects, passing through the original input unchanged.

**Syntax:**
```pointy
FOREACH<TemplateEvent>[attribute_list]
```

**Input Requirements:**
- Input must be a list/collection
- Template Event results are ignored

**Output:**
- Original input collection (unchanged)

**Attributes:**
- `concurrent` (boolean): Whether to execute instances in parallel
- `continue_on_error` (boolean): If true, continue even if some executions fail

**Example:**
```pointy
@users = [{"id": 1}, {"id": 2}, {"id": 3}]
LoadUsers |-> FOREACH<SendNotification>[concurrent=true] |-> LogCompletion
```

**Semantics:**
1. For each item, Template Event is executed
2. Template Event results are discarded
3. Original input collection is passed to next event unchanged
4. Useful for side effects like logging, notifications, or updates

---

### 4.5 FLATMAP Mode

**Purpose:** Execute the Template Event for each item, where each execution can return a collection, then flatten all results into a single list.

**Syntax:**
```pointy
FLATMAP<TemplateEvent>[attribute_list]
```

**Input Requirements:**
- Input must be a list/collection
- Template Event should return a list/collection (or single item)

**Output:**
- Flattened list of all results

**Attributes:**
- `concurrent` (boolean): Whether to execute instances in parallel
- `flatten_depth` (integer): How many levels to flatten (default: 1)

**Example:**
```pointy
@categories = ["electronics", "books", "clothing"]
LoadCategories |-> FLATMAP<FetchProductsInCategory> |-> ProcessAllProducts
```

**Semantics:**
1. For each item, Template Event is executed
2. Each result (which may be a list) is collected
3. All result lists are flattened into a single list
4. Flattening removes one level of nesting (or `flatten_depth` levels)

---

### 4.6 FANOUT Mode

**Purpose:** Execute the Template Event N times with the same input, broadcasting to multiple instances.

**Syntax:**
```pointy
FANOUT<TemplateEvent>[attribute_list]
```

**Input Requirements:**
- Any input type
- Input is passed unchanged to all instances

**Output:**
- List of results from all instances

**Attributes:**
- `count` (integer, REQUIRED): Number of instances to create
- `concurrent` (boolean): Whether to execute instances in parallel (default: true)

**Example:**
```pointy
@request = {"data": "payload"}
PrepareRequest |-> FANOUT<SendToReplica>[count=3, concurrent=true] -> AggregateResponses
```

**Semantics:**
1. Template Event is instantiated `count` times
2. Same input is provided to all instances
3. All instances execute (concurrently by default)
4. Results from all instances are collected and returned as a list

---

## 5. Execution Model

### 5.1 Meta Event Lifecycle

```
┌─────────────────────────────────────────────────────────────┐
│                    Meta Event Execution                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Orchestrator encounters Meta Event in pipeline          │
│  2. Meta Event.process() is called with input data          │
│  3. process() analyzes mode and input                       │
│  4. Dynamic Instruction Payload is generated                │
│  5. Orchestrator intercepts payload                         │
│  6. Orchestrator pauses main pipeline                       │
│  7. Dynamic tasks are executed                              │
│  8. Results are aggregated per mode semantics               │
│  9. Main pipeline resumes with aggregated result            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 Python Implementation Interface

Meta Events are implemented in Python as the `ControlFlowEvent` class:

```python
class ControlFlowEvent(EventBase):
    def __init__(self, mode: str, template_class: Type[EventBase], **mode_config):
        """
        Initialize a Meta Event.
        
        Args:
            mode: Execution mode (MAP, FILTER, REDUCE, etc.)
            template_class: The Template Event class to instantiate
            **mode_config: Mode-specific configuration parameters
        
        Raises:
            NestedMetaEventError: If template_class is a ControlFlowEvent
        """
        # Validate Template Event is not a Meta Event
        if isinstance(template_class, type) and issubclass(template_class, ControlFlowEvent):
            raise NestedMetaEventError(
                f"Template Event cannot be a Meta Event. "
                f"Found: {template_class.__name__}. "
                f"Nested Meta Events are prohibited."
            )
        
        self.mode = mode
        self.template_class = template_class
        self.mode_config = mode_config
    
    def process(self, *args, **kwargs):
        """
        Generate Dynamic Instruction Payload based on mode and input.
        
        Returns:
            DynamicInstructionPayload: List of task definitions
        """
        # Implementation generates payload based on mode
        pass
```

### 5.3 Orchestrator Responsibilities

The Orchestrator must:

1. **Detect Meta Events**: Identify when an event is a Meta Event
2. **Invoke process()**: Call the Meta Event's process method with input data
3. **Intercept Payload**: Recognize Dynamic Instruction Payload return type
4. **Pause Pipeline**: Temporarily halt main pipeline execution
5. **Execute Tasks**: Run all tasks defined in the payload
6. **Aggregate Results**: Combine results according to mode semantics
7. **Resume Pipeline**: Continue main pipeline with aggregated results

### 5.4 Execution Context

Meta Events execute within a single execution context by default. All Template Event instances generated by a Meta Event:

- Share the same executor (unless individually overridden)
- Inherit attributes from the Meta Event declaration
- Execute within the same logical transaction/scope

---

## 6. Integration with Existing Features

### 6.1 Attributes

Meta Event attributes apply at two levels:

#### 6.1.1 Meta-Level Attributes

These configure the Meta Event itself:

- `batch_size`: For modes like MAP
- `concurrent`: Parallel execution flag
- `count`: For FANOUT mode
- `initial_value`: For REDUCE mode

#### 6.1.2 Template-Level Attributes

These are inherited by all Template Event instances:

- `retries`: Retry count for each instance
- `executor`: Executor type for instances
- `executor_config`: Executor configuration

**Example:**
```pointy
MAP<ProcessItem>[
    batch_size=10,        # Meta-level
    concurrent=true,      # Meta-level
    retries=3,           # Template-level (inherited by each ProcessItem)
    executor="ThreadPoolExecutor"  # Template-level
]
```

### 6.2 Variable Usage

Variables can be used in Meta Event declarations:

```pointy
@batch = 20
@max_retry = 5
@worker_count = 10

MAP<ProcessItem>[batch_size=batch, retries=max_retry]
FANOUT<Worker>[count=worker_count]
```

### 6.3 Result Piping

Meta Events fully support result piping:

```pointy
# Pipe list to MAP
FetchItems |-> MAP<Transform> |-> SaveResults

# Chain multiple Meta Events
LoadData |-> MAP<Parse> |-> FILTER<Validate> |-> REDUCE<Aggregate>

# Pipe to conditional
MAP<ProcessItem> |-> CheckResults (
    0 |-> HandleErrors,
    1 |-> ContinueFlow
)
```

**Piping Semantics:**
- `|->` passes the Meta Event's output as input to the next event
- For MAP/FILTER/FLATMAP: Output is a list
- For REDUCE: Output is a single value
- For FOREACH: Output is the original input (unchanged)

### 6.4 Conditional Branching

Meta Events support conditional branching based on overall execution results:

```pointy
MAP<ProcessItem> (
    0 -> HandleFailures,    # All failed or partial failures
    1 -> HandleSuccess      # All succeeded
)
```

**Conditional Evaluation:**
- Descriptor 0: Any Template Event instance failed
- Descriptor 1: All Template Event instances succeeded
- Custom descriptors: Defined by Meta Event implementation

**Per-Instance vs Aggregate:**
By default, conditionals apply to the aggregate result. For per-instance conditionals, nest conditionals within the Template Event definition.

### 6.5 Grouping

Meta Events can be grouped in execution chains:

```pointy
{
    LoadData -> 
    MAP<Transform>[concurrent=true] -> 
    ValidateResults
}[executor="ThreadPoolExecutor", retries=2]
```

All events in the group share the specified attributes.

### 6.6 Parallel Execution with Meta Events

Meta Events can participate in parallel flows:

```pointy
MAP<ProcessTypeA> || MAP<ProcessTypeB> || MAP<ProcessTypeC>
```

Each Meta Event executes independently and concurrently.

---

## 7. Dynamic Instruction Payload

### 7.1 Payload Structure

The Dynamic Instruction Payload is a structured format that describes the tasks to be executed:

```python
DynamicInstructionPayload = {
    "meta_event_id": str,           # Unique ID for this Meta Event execution
    "mode": str,                     # Execution mode
    "aggregation_strategy": str,     # How to combine results
    "tasks": [                       # List of task definitions
        {
            "task_id": str,          # Unique ID for this task
            "template_class": Type,   # Template Event class
            "input_data": Any,        # Input for this instance
            "attributes": dict,       # Inherited + task-specific attributes
            "order": int              # Execution order (for ordered modes)
        },
        ...
    ]
}
```

### 7.2 Aggregation Strategies

Different modes use different aggregation strategies:

| Mode | Strategy | Description |
|------|----------|-------------|
| MAP | `collect_ordered` | Collect results in input order |
| FILTER | `filter_input` | Keep original items where predicate succeeded |
| REDUCE | `reduce_accumulate` | Progressively combine with accumulator |
| FOREACH | `pass_through` | Return original input unchanged |
| FLATMAP | `flatten_results` | Flatten collected results |
| FANOUT | `collect_all` | Collect all results (unordered) |

### 7.3 Task ID Generation

Task IDs are generated to ensure uniqueness and traceability:

```
{meta_event_id}_{template_name}_{index}
```

Example: `meta_001_ProcessItem_0`, `meta_001_ProcessItem_1`

### 7.4 Payload Example

```python
{
    "meta_event_id": "meta_12345",
    "mode": "MAP",
    "aggregation_strategy": "collect_ordered",
    "tasks": [
        {
            "task_id": "meta_12345_ProcessItem_0",
            "template_class": ProcessItem,
            "input_data": {"id": 1, "value": "item1"},
            "attributes": {"retries": 3, "executor": "ThreadPoolExecutor"},
            "order": 0
        },
        {
            "task_id": "meta_12345_ProcessItem_1",
            "template_class": ProcessItem,
            "input_data": {"id": 2, "value": "item2"},
            "attributes": {"retries": 3, "executor": "ThreadPoolExecutor"},
            "order": 1
        }
    ]
}
```

---

## 8. Error Handling

### 8.1 Meta Event Errors

Errors can occur at multiple levels:

#### 8.1.1 Configuration Errors
- Invalid mode specified
- Missing required attributes (e.g., `count` for FANOUT)
- Template Event class not found
- Type mismatch (e.g., non-collection input to MAP)

These errors are caught at parse-time or initialization.

#### 8.1.2 Runtime Errors
- Template Event execution failures
- Timeout exceeded
- Resource exhaustion

These errors are handled according to retry and error handling policies.

### 8.2 Partial Failure Handling

Different modes handle partial failures differently:

#### MAP Mode
- **Default**: If any instance fails, entire MAP fails (descriptor 0)
- **Optional**: With `partial_success=true`, collect successful results and continue
- Failed instances can be logged separately

#### FILTER Mode
- **Default**: Failed predicates exclude items (treat as false)
- **Optional**: With `keep_on_error=true`, failed items are included

#### REDUCE Mode
- **Default**: Any failure aborts the reduction
- **Optional**: With `skip_errors=true`, skip failed items and continue

#### FOREACH Mode
- **Default**: With `continue_on_error=true`, continue even if instances fail
- All failures are logged

### 8.3 Error Propagation

```pointy
MAP<ProcessItem>[retries=3] (
    0 -> LogAllErrors -> NotifyAdmin -> Rollback,
    1 -> ValidateResults -> SaveToDatabase
)
```

When a Meta Event fails:
1. Template Event errors are collected
2. Meta Event returns descriptor 0
3. Conditional branch 0 is taken
4. Error information is piped if using `|->`

### 8.4 Error Information Structure

Error details from Meta Events include:

```python
{
    "meta_event_id": str,
    "mode": str,
    "total_tasks": int,
    "successful_tasks": int,
    "failed_tasks": int,
    "errors": [
        {
            "task_id": str,
            "template_class": str,
            "input_data": Any,
            "error_message": str,
            "error_type": str,
            "timestamp": str
        },
        ...
    ]
}
```

---

### 8.5 Edge Cases in Error Handling

This section defines behavior for edge cases and unusual error scenarios.

#### 8.5.1 Empty Input Collections

**Scenario**: Meta Event receives an empty list/collection as input.

**Behavior by Mode**:

| Mode | Behavior | Descriptor | Output |
|------|----------|------------|--------|
| MAP | Return empty list | 1 (success) | `[]` |
| FILTER | Return empty list | 1 (success) | `[]` |
| REDUCE | Raise error if no `initial_value` | 0 (failure) | Error |
| REDUCE | Return `initial_value` if provided | 1 (success) | `initial_value` |
| FOREACH | Return empty list immediately | 1 (success) | `[]` |
| FLATMAP | Return empty list | 1 (success) | `[]` |
| FANOUT | N/A (not collection-based) | N/A | N/A |

**Example**:
```pointy
@empty_list = []

# Returns empty list with descriptor 1
LoadData |-> MAP<ProcessItem> |-> SaveResults

# Raises error - no initial_value
LoadData |-> REDUCE<Sum> (
    0 -> HandleEmptyCollection,
    1 -> ContinueFlow
)

# Returns 0 with descriptor 1
LoadData |-> REDUCE<Sum>[initial_value=0] |-> DisplayTotal
```

---

#### 8.5.2 Single Item Collections

**Scenario**: Meta Event receives a collection with only one item.

**Behavior by Mode**:

| Mode | Behavior | Notes |
|------|----------|-------|
| MAP | Process single item, return list with one result | `[result]` |
| FILTER | Evaluate predicate on single item | Returns `[]` or `[item]` |
| REDUCE | Return item if no `initial_value`, else reduce once | Single reduction step |
| FOREACH | Execute Template Event once, return original | `[item]` |
| FLATMAP | Process single item, flatten result | Depends on item result |
| FANOUT | N/A | N/A |

**Example**:
```pointy
@single_item = [{"id": 1, "value": 100}]

# Processes one item, returns [result]
LoadData |-> MAP<ProcessItem> |-> SaveResults

# If initial_value=0: performs 0 + 100 = 100
# If no initial_value: returns 100 directly
LoadData |-> REDUCE<Sum>[initial_value=0] |-> DisplayTotal
```

---

#### 8.5.3 Null/None Input

**Scenario**: Meta Event receives `null`/`None` as input.

**Behavior**:
- **All collection-based modes** (MAP, FILTER, REDUCE, FOREACH, FLATMAP): Raise `TypeError` with descriptor 0
- **FANOUT**: Can accept null input (broadcasts null to all instances)

**Example**:
```pointy
# Raises TypeError - null is not iterable
FetchData |-> MAP<ProcessItem> (
    0 -> HandleNullInput -> UseDefaultData,
    1 -> ContinueFlow
)

# Valid - broadcasts null to 3 instances
PrepareRequest |-> FANOUT<SendRequest>[count=3]
```

**Recommendation**: Always validate input before Meta Events:
```pointy
FetchData -> ValidateNotNull (
    0 -> UseDefaultData,
    1 -> MAP<ProcessItem>
) -> ContinueFlow
```

---

#### 8.5.4 Type Mismatch in Input

**Scenario**: Meta Event receives input of wrong type (e.g., string instead of list).

**Behavior**:
- Raise `TypeError` at runtime with descriptor 0
- Error message indicates expected vs actual type
- No partial processing occurs

**Example**:
```pointy
# Returns string "hello" instead of list
FetchData |-> MAP<ProcessItem> (
    0 -> LogTypeError -> RetryWithCorrection,
    1 -> ContinueFlow
)

# Error: "Expected collection type for MAP mode, got <class 'str'>"
```

**Type Requirements by Mode**:
- MAP, FILTER, FOREACH, FLATMAP: Require iterable (list, tuple, set)
- REDUCE: Require iterable with at least one item (if no `initial_value`)
- FANOUT: Accept any type

---

#### 8.5.5 All Template Events Fail with Retries

**Scenario**: Every Template Event instance fails even after all retry attempts.

**Behavior**:
- Meta Event returns descriptor 0
- All individual errors are collected in error structure
- No partial results are returned (unless `partial_success=true`)

**Example**:
```pointy
@items = [1, 2, 3, 4, 5]

# All 5 instances fail after 3 retries each (15 total attempts)
LoadItems |-> MAP<UnreliableProcess>[retries=3] (
    0 |-> CollectAllErrors -> AnalyzeFailurePattern -> NotifyCritical,
    1 -> SaveResults
)
```

**Error Structure**:
```python
{
    "meta_event_id": "meta_001",
    "mode": "MAP",
    "total_tasks": 5,
    "successful_tasks": 0,
    "failed_tasks": 5,
    "errors": [
        {"task_id": "meta_001_UnreliableProcess_0", "attempts": 3, ...},
        {"task_id": "meta_001_UnreliableProcess_1", "attempts": 3, ...},
        # ... all 5 failures
    ]
}
```

---

#### 8.5.6 Partial Success with `partial_success=true`

**Scenario**: Some Template Events succeed, others fail, with `partial_success=true` enabled.

**Behavior**:
- Meta Event returns descriptor 1 (success)
- Output contains only successful results
- Failed items are logged but not included in output
- Failure details available in metadata

**Example**:
```pointy
@items = [1, 2, 3, 4, 5]

# Items 2 and 4 fail, but 1, 3, 5 succeed
LoadItems |-> MAP<SometimesFailsProcess>[partial_success=true, retries=2] (
    0 -> UnexpectedBranch,  # Won't be taken
    1 -> ProcessResults     # Continues with [result1, result3, result5]
) -> FinalStep
```

**Output Structure**:
```python
{
    "results": [result1, result3, result5],  # Only successful items
    "metadata": {
        "total_attempted": 5,
        "successful": 3,
        "failed": 2,
        "failed_indices": [1, 3]  # Original positions of failed items
    }
}
```

**Warning**: Output length may differ from input length. Downstream events must handle variable-length results.

---

#### 8.5.7 Timeout During Meta Event Execution

**Scenario**: Meta Event execution exceeds timeout limit.

**Behavior**:
- In-progress Template Events are cancelled/interrupted
- Completed results up to timeout are discarded (unless `partial_success=true`)
- Meta Event returns descriptor 0
- Timeout error is raised

**Example**:
```pointy
@items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Timeout after 30 seconds - only 5 items processed
LoadItems |-> MAP<SlowProcess>[
    timeout=30.0,
    concurrent=true,
    partial_success=false
] (
    0 -> HandleTimeout -> RetryWithSmallerBatch,
    1 -> SaveResults
)
```

**Recommendation**: For long-running operations:
```pointy
# Better approach: batch processing with per-item timeout
LoadItems |-> MAP<SlowProcess>[
    batch_size=5,
    timeout=10.0,        # Per-item timeout
    concurrent=true,
    partial_success=true  # Allow partial completion
]
```

---

#### 8.5.8 Resource Exhaustion During Parallel Execution

**Scenario**: System runs out of resources (memory, file handles, connections) during concurrent Meta Event execution.

**Behavior**:
- System raises `ResourceError`
- Partial results are lost (unless explicitly persisted)
- Meta Event returns descriptor 0
- Orchestrator may need to restart or scale back

**Example**:
```pointy
@huge_dataset = [1, 2, 3, ..., 1000000]  # 1 million items

# Attempting to process all concurrently - likely to fail
LoadData |-> MAP<MemoryIntensiveProcess>[
    concurrent=true,
    max_concurrency=1000  # Too high!
] (
    0 -> HandleResourceError -> ScaleBackAndRetry,
    1 -> SaveResults
)
```

**Mitigation Strategy**:
```pointy
# Better approach: limit concurrency and use batching
@max_workers = 10
@batch = 1000

LoadData |-> MAP<MemoryIntensiveProcess>[
    concurrent=true,
    max_concurrency=max_workers,
    batch_size=batch
] (
    0 -> LogError -> ReduceConcurrency -> Retry,
    1 -> SaveResults
)
```

---

#### 8.5.9 Template Event Returns Unexpected Descriptor

**Scenario**: Template Event returns a descriptor not defined in conditional branches.

**Behavior**:
- If descriptor is not 0 or 1, and no branch defined for it
- Meta Event treats it as failure (descriptor 0)
- Warning is logged about undefined descriptor
- Error branch is taken (if defined)

**Example**:
```pointy
# Template Event returns descriptor 3, but only 0 and 1 are handled
LoadItems |-> MAP<ProcessWithCustomDescriptors> (
    0 -> HandleFailure,
    1 -> HandleSuccess
    # No branch for descriptor 3!
)

# Descriptor 3 is treated as failure, goes to HandleFailure
```

**Proper Handling**:
```pointy
# Define all possible descriptors
LoadItems |-> MAP<ProcessWithCustomDescriptors> (
    0 -> HandleFailure,
    1 -> HandleSuccess,
    3 -> HandlePartialSuccess,
    5 -> HandleNeedsReview
)
```

---

#### 8.5.10 Nested Meta Event Failure

**Scenario**: A Template Event attempts to use a Meta Event internally.

**Status**: This scenario is **PROHIBITED** by the **No Nested Meta Events** rule (Section 2.4.1).

**Behavior**:
- Detected at parse time or initialization
- Raise `NestedMetaEventError`
- Pipeline fails before execution begins
- Clear error message indicates the violation

**Example**:
```pointy
# INVALID - ProcessGroup cannot internally use MAP
LoadGroups |-> MAP<ProcessGroup>[concurrent=true]

# Where ProcessGroup tries to do:
# MAP<ProcessItem> on each group's items
# This is NOT ALLOWED
```

**Error Message**:
```
NestedMetaEventError: Template Event 'ProcessGroup' contains a Meta Event, which is prohibited.
Meta Events cannot be nested. Use explicit sequential composition instead.
```

**Correct Alternative**:
```pointy
# VALID - Flatten the logic explicitly
@groups = [
    {"items": [1, 2, 3]},
    {"items": [4, 5, 6]},
    {"items": [7, 8, 9]}
]

LoadGroups |-> 
FLATMAP<ExtractGroupItems> |->  # Flatten all groups into single list
MAP<ProcessItem>[concurrent=true] |->  # Process all items
REDUCE<GroupResults>  # Re-aggregate by group if needed
```

---

#### 8.5.11 REDUCE with Non-Commutative Operations and Errors

**Scenario**: REDUCE operation is non-commutative (order matters) and some items cause errors.

**Behavior**:
- With `skip_errors=false` (default): First error aborts entire reduction
- With `skip_errors=true`: Error items are skipped, reduction continues
- Order is preserved for remaining items

**Example**:
```pointy
@numbers = [10, 5, 0, 20, 15]  # Division by zero at index 2

# Division is non-commutative: (10 / 5) / 0 != 10 / (5 / 0)
LoadNumbers |-> REDUCE<Divide>[
    skip_errors=true
] (
    0 -> HandleDivisionError,
    1 -> DisplayResult  # Result is (10 / 5) / 20 / 15
)
```

**Warning**: Skipping errors in REDUCE can produce unexpected results if operation is non-commutative or non-associative.

**Recommendation**: For critical reductions, use `skip_errors=false` (default).

---

#### 8.5.12 FILTER with All Items Filtered Out

**Scenario**: FILTER mode filters out every item in the collection.

**Behavior**:
- Returns empty list `[]`
- Returns descriptor 1 (success)
- Downstream events receive empty collection

**Example**:
```pointy
@users = [
    {"age": 15},
    {"age": 17},
    {"age": 16}
]

# All users under 18 - all filtered out
LoadUsers |-> FILTER<IsAdult>[concurrent=true] |-> SendMarketingEmail

# SendMarketingEmail receives [] - effectively a no-op
```

**Handling**:
```pointy
# Better approach: check for empty result
LoadUsers |-> 
FILTER<IsAdult>[concurrent=true] |-> 
CheckNotEmpty (
    0 -> LogNoAdultUsers,
    1 -> SendMarketingEmail
)
```

---

#### 8.5.13 FANOUT with count=0

**Scenario**: FANOUT mode specified with `count=0`.

**Behavior**:
- Raise `ValueError` at initialization
- Error: "FANOUT count must be positive integer"
- Pipeline fails before execution begins

**Example**:
```pointy
@worker_count = 0

# Raises ValueError during pipeline initialization
PrepareRequest |-> FANOUT<SendRequest>[count=worker_count] (
    0 -> HandleError,
    1 -> ProcessResponses
)
```

**Validation**: `count` attribute is validated at parse-time or initialization, not at runtime.

---

#### 8.5.14 Circular Dependencies with Meta Events

**Scenario**: Template Event references a Meta Event that eventually references the original Template Event (circular dependency).

**Status**: This scenario is prevented by the **No Nested Meta Events** rule (Section 2.4.1).

**Behavior**:
- Nested Meta Events are prohibited
- Detected at parse time or initialization
- Raise `NestedMetaEventError` before `CircularDependencyError` can occur

**Note**: This edge case is eliminated by design. Circular dependencies between regular Events are still detected separately.

---

#### 8.5.15 Mixed Success/Failure with Conditional Branching

**Scenario**: Meta Event has partial failures, `partial_success=false`, but also has conditional branching.

**Behavior**:
- Meta Event fails (descriptor 0)
- Error branch is taken
- Successful partial results are available in error metadata but not passed forward

**Example**:
```pointy
@items = [1, 2, 3, 4, 5]

# Items 1, 3, 5 succeed; items 2, 4 fail
LoadItems |-> MAP<SometimesFails>[partial_success=false] (
    0 |-> AccessFailureDetails,  # Can access which items succeeded
    1 -> ProcessResults
)
```

**Error Data Piped to Branch 0**:
```python
{
    "meta_event_id": "meta_001",
    "descriptor": 0,
    "partial_results": {
        "successful": [result1, result3, result5],
        "failed_indices": [1, 3]
    },
    "errors": [...]
}
```

---

#### 8.5.16 FLATMAP Returns Non-Collection

**Scenario**: FLATMAP Template Event returns a non-collection type (e.g., integer, string).

**Behavior**:
- Non-collection results are treated as single-item collections
- Flattening proceeds normally
- Final result includes these items as-is

**Example**:
```pointy
@items = [1, 2, 3]

# ProcessItem returns:
# - For 1: [10, 11, 12]  (list)
# - For 2: 20            (integer - treated as [20])
# - For 3: [30, 31]      (list)

LoadItems |-> FLATMAP<ProcessItem>
# Result: [10, 11, 12, 20, 30, 31]
```

**Type Coercion Rules**:
- Lists/Tuples: Flattened normally
- Single values: Wrapped as single-item list
- None: Treated as empty list `[]`
- Dictionaries: Treated as single item (not flattened)

---

#### 8.5.17 Executor Incompatibility with Meta Event Mode

**Scenario**: Meta Event requires concurrent execution but specified executor doesn't support it.

**Behavior**:
- Raise `ExecutorIncompatibilityError` at initialization
- Error indicates which executor and mode are incompatible
- Pipeline fails before execution

**Example**:
```pointy
# XMLRPCExecutor doesn't support parallel execution
MAP<ProcessItem>[
    concurrent=true,
    executor="XMLRPCExecutor"
] (
    0 -> HandleError,
    1 -> ContinueFlow
)

# Raises: "XMLRPCExecutor does not support concurrent execution required by MAP mode"
```

**Compatibility Matrix** (from v1.1.0):
- ThreadPoolExecutor: Supports concurrent
- ProcessExecutor: Supports concurrent
- XMLRPCExecutor: Does NOT support concurrent

**Mitigation**:
```pointy
# Either: change executor
MAP<ProcessItem>[concurrent=true, executor="ThreadPoolExecutor"]

# Or: disable concurrency
MAP<ProcessItem>[concurrent=false, executor="XMLRPCExecutor"]
```

---

#### 8.5.18 Memory Leak from Unreleased Resources in Template Events

**Scenario**: Template Events don't properly release resources (connections, files), causing gradual resource exhaustion.

**Behavior**:
- Not directly handled by Meta Event
- Accumulates over many executions
- Eventually causes system failure
- Error may not be obvious until late in execution

**Example**:
```pointy
@large_dataset = [1, 2, 3, ..., 100000]

# Template Event opens file/connection but doesn't close it
LoadData |-> MAP<ProcessWithResourceLeak>[concurrent=true]
# After ~10000 items: "Too many open files" error
```

**Responsibility**: Template Event implementations MUST properly manage resources.

**Recommendation**: Use context managers in Python implementations:
```python
class ProcessItem(EventBase):
    def process(self, item):
        with open(f"file_{item}.txt") as f:  # Properly closes
            # Process file
            pass
        return True, result
```

---

### 8.6 Error Recovery Strategies

#### 8.6.1 Graceful Degradation

```pointy
# Primary path with fallback
FetchDataFromPrimary |-> MAP<ProcessPrimary>[partial_success=true] (
    0 |-> CheckPartialResults (
        0 -> FetchFromBackup |-> MAP<ProcessBackup>,
        1 -> ContinueWithPartial -> LogDegradedMode
    ),
    1 -> ContinueNormally
)
```

#### 8.6.2 Retry with Backoff

```pointy
@retry_delays = [1, 2, 5, 10, 30]

LoadData |-> MAP<UnreliableProcess>[retries=5, retry_delays=retry_delays] (
    0 -> LogPermanentFailure,
    1 -> ContinueFlow
)
```

#### 8.6.3 Circuit Breaker Pattern

```pointy
# Monitor failure rate and stop if too high
LoadItems |-> MAP<ProcessItem>[
    concurrent=true,
    circuit_breaker_threshold=0.5,  # Stop if >50% fail
    circuit_breaker_window=100       # Over 100 items
] (
    0 -> CircuitOpen -> WaitAndRetry,
    1 -> ContinueProcessing
)
```

---

### 8.7 Debugging Meta Event Failures

#### 8.7.1 Enable Detailed Logging

```pointy
MAP<ProcessItem>[
    debug_mode=true,           # Log each Template Event execution
    trace_execution=true,      # Track execution timeline
    log_level="DEBUG"
]
```

#### 8.7.2 Isolate Failing Items

```pointy
# Re-run with just the failed items
LoadFailedItems |-> MAP<ProcessItem>[
    concurrent=false,          # Sequential for easier debugging
    stop_on_first_error=true  # Stop immediately on first failure
]
```

#### 8.7.3 Use Smaller Batches

```pointy
# Reduce blast radius during debugging
LoadData |-> MAP<ProcessItem>[
    batch_size=1,              # Process one at a time
    concurrent=false
]
```

---

## 9. Grammar Specification

### 9.1 Extended BNF for Meta Events

```ebnf
(* Existing grammar rules from v1.0.0 - v1.1.1 *)

(* Meta Event extensions *)
meta_event ::= mode '<' template_event '>' attribute_list?

mode ::= 'MAP' | 'FILTER' | 'REDUCE' | 'FOREACH' | 'FLATMAP' | 'FANOUT'

template_event ::= identifier

(* Updated primary expression to include meta events *)
primary_expr ::= identifier 
               | meta_event
               | '(' expression ')'

(* Meta Event attributes *)
meta_attribute ::= 'batch_size' '=' integer
                 | 'concurrent' '=' boolean
                 | 'count' '=' integer
                 | 'initial_value' '=' value
                 | 'direction' '=' string_literal
                 | 'keep_on_error' '=' boolean
                 | 'continue_on_error' '=' boolean
                 | 'flatten_depth' '=' integer
                 | 'partial_success' '=' boolean
```

### 9.2 Complete Grammar Integration

```ebnf
pipeline         ::= expression

expression       ::= conditional_expr

conditional_expr ::= pipe_expr ('(' condition_list ')')?

condition_list   ::= condition (',' condition)*

condition        ::= descriptor ('->' | '|->') pipe_expr

pipe_expr        ::= parallel_expr ('|->' parallel_expr)*

parallel_expr    ::= sequential_expr ('||' sequential_expr)*

sequential_expr  ::= retry_expr ('->' retry_expr)*

retry_expr       ::= primary_expr ('*' retry_count)?

primary_expr     ::= identifier 
                   | meta_event
                   | grouped_statement
                   | '(' expression ')'

meta_event       ::= mode '<' identifier '>' attribute_list?

mode             ::= 'MAP' | 'FILTER' | 'REDUCE' | 'FOREACH' | 'FLATMAP' | 'FANOUT'

grouped_statement ::= '{' expression '}' attribute_list?

attribute_list   ::= '[' attribute (',' attribute)* ']'

attribute        ::= identifier '=' value

value            ::= scalar_type | map | list | variable_reference

descriptor       ::= '0'..'9'

retry_count      ::= [1-9][0-9]*

identifier       ::= [a-zA-Z_][a-zA-Z0-9_]*
```

---

## 10. Examples

### 10.1 Simple MAP Operation

```pointy
# Process a list of user IDs
@user_ids = [101, 102, 103, 104, 105]

FetchUserIds |-> MAP<EnrichUserData>[concurrent=true, retries=2] |-> SaveToCache
```

### 10.2 Filter and Process

```pointy
# Filter adult users and process
@users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 17},
    {"name": "Charlie", "age": 30}
]

LoadUsers |-> 
FILTER<IsAdult>[concurrent=true] |-> 
MAP<SendMarketingEmail>[batch_size=10] |->
LogResults
```

### 10.3 Data Aggregation Pipeline

```pointy
# Aggregate sales data
@sales_records = [
    {"amount": 100, "region": "North"},
    {"amount": 200, "region": "South"},
    {"amount": 150, "region": "North"}
]

LoadSalesData |->
MAP<ValidateRecord>[concurrent=true] |->
FILTER<IsValidSale> |->
REDUCE<SumAmounts>[initial_value=0] |->
PublishTotalSales
```

### 10.4 Complex Multi-Stage Pipeline

```pointy
@batch_size = 50
@retry_count = 3

# Extract, transform, load pipeline
FetchRawData |->
MAP<ParseRecord>[batch_size=batch_size, concurrent=true, retries=retry_count] (
    0 -> LogParseErrors -> NotifyDataTeam,
    1 -> FILTER<ValidateSchema>[concurrent=true] |->
         MAP<TransformToTargetFormat>[concurrent=true] |->
         REDUCE<BatchInsert>[batch_size=100] (
             0 -> RollbackChanges -> AlertAdmin,
             1 -> CommitTransaction -> SendSuccessNotification
         )
)
```

### 10.5 Fan-Out to Multiple Services

```pointy
# Broadcast request to multiple replicas for redundancy
@request_payload = {"query": "search term", "filters": {...}}

PrepareRequest |->
FANOUT<SendToSearchReplica>[count=3, concurrent=true] |->
SelectFastestResponse |->
FormatResults |->
CacheAndReturn
```

### 10.6 Parallel Processing with Different Meta Events

```pointy
# Process different data types in parallel
@data_batch = {"type_a": [...], "type_b": [...], "type_c": [...]}

SplitDataByType -> (
    ExtractTypeA |-> MAP<ProcessTypeA>[concurrent=true] ||
    ExtractTypeB |-> MAP<ProcessTypeB>[concurrent=true] ||
    ExtractTypeC |-> FLATMAP<ProcessTypeC>[concurrent=true]
) |-> MergeResults |-> FinalValidation
```

### 10.7 Nested Meta Events (Advanced)

**NOTE**: This pattern is **PROHIBITED** in Pointy Language v1.2.0. Nested Meta Events are not allowed (see Section 2.4.1).

**Instead, use explicit composition**:

```pointy
# Process groups of items using flattened composition
@grouped_data = [
    {"group": "A", "items": [1, 2, 3]},
    {"group": "B", "items": [4, 5, 6]}
]

LoadGroupedData |->
FLATMAP<ExtractItems>[concurrent=true] |->  # Flatten all groups to items
MAP<ProcessItem>[concurrent=true] |->        # Process all items
REDUCE<AggregateByGroup> |->                 # Re-group results
GenerateReport
```

This achieves the same result as nesting would, but with:
- Clearer execution flow
- Better performance characteristics
- Easier debugging
- Predictable resource usage

### 10.8 Error Handling with Meta Events

```pointy
@critical_operations = [op1, op2, op3]

LoadOperations |->
MAP<ExecuteCriticalOperation>[retries=5, concurrent=false] (
    0 |-> FOREACH<LogFailure>[continue_on_error=true] |->
          NotifyOnCallEngineer |->
          InitiateRollback,
    1 -> ValidateAllSuccess -> UpdateStatus
)
```

### 10.9 FOREACH for Side Effects

```pointy
@notification_list = [
    {"user": "alice", "message": "..."},
    {"user": "bob", "message": "..."}
]

PrepareNotifications |->
FOREACH<SendEmail>[concurrent=true, continue_on_error=true] |->
LogCompletionStatus  # Original notification_list is passed through
```

### 10.10 Using Variables with Meta Events

```pointy
@parallel_workers = 5
@batch_config = {"size": 100, "timeout": 30}
@enable_retry = true

ConfigureSystem[worker_count=parallel_workers] ->
FetchWorkQueue |->
MAP<ProcessWorkItem>[
    batch_size=batch_config["size"],
    concurrent=true,
    retries=enable_retry ? 3 : 0
] |->
UpdateMetrics
```

---

## Appendix A: Meta Event Mode Summary

| Mode | Input | Output | Primary Use Case |
|------|-------|--------|------------------|
| MAP | Collection | Collection | Transform each item |
| FILTER | Collection | Collection (subset) | Keep items matching predicate |
| REDUCE | Collection | Single value | Aggregate/combine items |
| FOREACH | Collection | Original collection | Side effects only |
| FLATMAP | Collection | Flattened collection | Transform and flatten nested results |
| FANOUT | Any | Collection | Broadcast to N instances |

## Appendix B: Attribute Reference

### Meta-Level Attributes

| Attribute | Type | Applicable Modes | Description |
|-----------|------|------------------|-------------|
| `batch_size` | integer | MAP, FILTER, FLATMAP | Items per processing batch |
| `concurrent` | boolean | MAP, FILTER, FOREACH, FLATMAP | Enable parallel execution |
| `max_concurrency` | integer | MAP, FILTER, FLATMAP | Max parallel instances |
| `count` | integer | FANOUT | Number of instances to create |
| `initial_value` | any | REDUCE | Starting accumulator value |
| `direction` | string | REDUCE | "left" or "right" reduction |
| `keep_on_error` | boolean | FILTER | Include items that error |
| `continue_on_error` | boolean | FOREACH | Continue despite errors |
| `flatten_depth` | integer | FLATMAP | Levels to flatten |
| `partial_success` | boolean | MAP, FILTER | Allow partial results |

### Template-Level Attributes (Inherited)

| Attribute | Type | Description |
|-----------|------|-------------|
| `retries` | integer | Retry count for each instance |
| `executor` | string | Executor type for instances |
| `executor_config` | map | Executor configuration |
| `timeout` | float | Timeout per instance |

## Appendix C: Migration Guide

### From v1.1.1 to v1.2.0

**No Breaking Changes**: v1.2.0 is fully backward compatible with v1.1.1.

**New Capabilities:**
1. Replace custom loop logic with MAP Meta Events
2. Use FILTER instead of conditional chains for collection filtering
3. Use REDUCE for aggregation instead of manual accumulation
